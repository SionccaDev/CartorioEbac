# -*- coding: utf-8 -*-
"""Trabalho score de crédito

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lSlieVlVdfvGT4pcDNiLDU7HN9Z5qMKF

# Tendências a inadimplência: Uma análise aprofundada

Lucca Forte Chanquetti

# 1. Discussão

Temos um banco de dados disponível de uma instituição financeira com mais de **10.000 identidades** de clientes para análise, onde temos uma variável dependente denominada `default`, que é a segunda coluna do arquivo csv. Essa em especial pode possuir dois stats: para **adimplente** (`default` == 0) ou para **inadimplente** (`default` == 1).

Estudaremos essas variáveis dependentes com as variáveis independentes concomitantemente - que são as outras colunas - para obtermos *insights* sobre o que tem relação com um cliente possuir **tendência** a se tornar inadimplente **ou não**.
Esses *insights* então, serão utilizados para a resolução de problemas por parte da equipe de planejamento estratégico.

| Coluna  | Descrição |
| ------- | --------- |
| id      | Número da conta |
| default | Indica se o cliente é adimplente (0) ou inadimplente (1) |
| idade   | --- |
| sexo    | --- |
| depedentes | --- |
| escolaridade | --- |
| estado_civil | --- |
| salario_anual | Faixa do salario mensal multiplicado por 12 |
| tipo_cartao | Categoria do cartao: blue, silver, gold e platinium |
| meses_de_relacionamento | Quantidade de meses desde a abertura da conta |
| qtd_produtos | Quantidade de produtos contratados |
| iteracoes_12m | Quantidade de iteracoes com o cliente no último ano |
| meses_inatico_12m | Quantidade de meses que o cliente ficou inativo no último ano |
| limite_credito | Valor do limite do cartão de crédito |
| valor_transacoes_12m | Soma total do valor das transações no cartão de crédito no último ano |
| qtd_transacoes_12m | Quantidade total de transações no cartão de crédito no último ano |

Começaremos importando os **pacotes** necessários para o notebook, e depois, extraindo o link que leva a um arquivo em formato .csv, para formar um dataframe pandas:
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

sns.set_style('whitegrid')

df = pd.read_csv('https://raw.githubusercontent.com/andre-marcos-perez/ebac-course-utils/develop/dataset/credito.csv', na_values="na")

"""# 2. Explorando a estrutura"""

df.head(n=8)  # first glance

df.shape  # o número de linhas e colunas do dataframe, respectivamente

adimplentes = df[df['default'] == 0].shape[0]
print(adimplentes)  # mostra a quantidade de adimplentes

inadimplentes = df[df['default'] == 1].shape[0]
print(inadimplentes)  # mostra a quantidade de inadimplentes

"""Deixando os dados mais digeríveis:"""

porc_adimplentes = round(100 * adimplentes / (adimplentes + inadimplentes),2)
porc_inadimplentes = round(100 * inadimplentes / (adimplentes + inadimplentes),2)

print(f'A porcentagem de adimplentes é de {porc_adimplentes}%.')
print(f'A porcentagem de inadimplentes é de {porc_inadimplentes}%.')

"""# 3. Manipulação e correção dos dados

Usando o método `info()`, observamos que `limite_credito` e `valor_transacoes_12m` estão em formato de string, sendo que deveriam ser floats pois tratam-se de valores monetários. Também observamos que: `escolaridade`, `estado_civil` e `salario_anual` possuem valores nulos (`na`).

Além disso, nota-se que a coluna `id` está em formato de int, mas isso não afetará em nada o processo analítico.
"""

df.info()

def dados_faltantes(df: pd.DataFrame) -> None:  # função para criar uma lista de dicts contendo dados sobre os clientes com 'na'

  dados_faltantes = []
  for col in df.columns:
    if df[col].isna().any():
      qtd = df[df[col].isna()].shape[0]
      total_clientes = df.shape[0] #10127 clientes
      dict_dados_faltantes = {col: {'quantidade': qtd, "porcentagem": round(100 * qtd / total_clientes, 2)}}
      dados_faltantes.append(dict_dados_faltantes)

  for stat in dados_faltantes:
    print(stat)

"""Esses dados mostram a quantidade de `na` nessas 3 colunas, assim como a **porcentagem** em relação ao total de clientes:"""

resultado_faltantes = dados_faltantes(df=df)

"""Nesses trechos, vemos que as porcentagens são muito **similares** entre si:"""

print("NA's adimplentes:")
resultado_adimplentes = dados_faltantes(df=df[df['default'] == 0])
print('\n')
print("NA's inadimplentes:")
resultado_inadimplentes = dados_faltantes(df=df[df['default'] == 1])

"""Então, comparando-se as porcentagens é aceitável **excluir** os clientes com dados faltantes (`na`), pois em relação ao número total de clientes, a variação probabilística é **irrisória**.
A exclusão dos clientes contendo dados nulos evita eventuais problemas de código, além de sua ausência ser insignificante para os resultados finais.

Com esse simples método, excluimos do dataframe todos os dados problemáticos:
"""

df.dropna(inplace=True) # o inplace=True indica que o dataframe original será modificado
df.shape

"""Vamos resolver o problema das colunas `limite_credito` e `valor_transacoes_12m` estarem em formato de **str** ao invés de **float**. Antes, vamos analisar de perto:"""

df_errado = df[['limite_credito','valor_transacoes_12m']]
df_errado.head(n=5)

df.select_dtypes('object').describe().transpose() # limite_credito e valor_transacoes_12m estão presentes

df.drop('id', axis=1).select_dtypes('int').describe().transpose() # limite_credito e valor_transacoes_12m não estão presentes

"""Diante desses trechos, podemos inferir que essas colunas estão em formato de **str** porque o **python** trabalha com o sistema de **numeração decimal** -- predominante em **países anglófonos** -- onde um ' **.** ' (ponto) ao invés da ' **,** ' (vírgula) é usado como delimitador decimal.

Criamos então, uma função quase anônima **lambda** para substituir os caracteres:
"""

fl = lambda x: float(x.replace(".","").replace(",","."))

def fl(x):
  try:
    return float(x.replace(".","").replace(",","."))
  except AttributeError:  # para prevenir que já existam valores em float
    return x

df['limite_credito'] = df['limite_credito'].apply(fl) # o apply() é uma função nativa do python que aplica a função a todas as colunas
df['valor_transacoes_12m'] = df['valor_transacoes_12m'].apply(fl)

df.select_dtypes('float').describe().transpose()

"""Os valores foram convertidos de **str** para **float** com sucesso.

Mostrando a versão polida do dataframe, temos novos números de adimplentes e inadimplentes:
"""

df[df['default'] == 0].shape

df[df['default'] == 1].shape

"""Para aspecto comparativo:"""

df_atualizado = df.shape[0]
adimplentes_novo = df[df['default'] == 0].shape[0]
inadimplentes_novo = df[df['default'] == 1].shape[0]

print(f'A porcentagem de adimplentes no dataframe filtrado é de {round(100 * adimplentes_novo / df_atualizado,2)}%, enquanto a porcentagem de adimplentes no dataframe original é de {porc_adimplentes}%.')
print('')
print(f'A porcentagem de inadimplentes no dataframe filtrado é de {round(100 * inadimplentes_novo / df_atualizado,2)}%, enquanto a porcentam de inadimplentes no dataframe original é de {porc_inadimplentes}%.')

"""# 4. Visualização dos dados"""

df_adimplentes = df[df['default'] == 0]
df_inadimplentes = df[df['default'] == 1]

"""Uma vez que temos nosso dataframe mais refinado, podemos trazê-lo em formas mais **visuais** e **interpretativas** para nossa análise de dados. Trabalharemos comparando algumas variáveis **preditivas** com `default`, tanto **categóricas** quanto **numéricas**."""

df.select_dtypes('object').head(n=5)  # usaremos estado_civil e salario_anual como variáveis independentes categóricas

"""Criaremos um gráfico em **barras** usando os dados da coluna `estado_civil`:"""

coluna = 'estado_civil'
titulos = ['Estado civil dos Clientes', 'Estado civil dos Clientes Adimplentes', 'Estado civil dos Clientes Inadimplentes']

eixo = 0
max_y_value = 0

figura, eixos = plt.subplots(1, 3, figsize=(20, 5), sharex=True)

for dataframe in [df, df_adimplentes, df_inadimplentes]:
    df_to_plot = dataframe[coluna].value_counts().reset_index()
    df_to_plot.columns = [coluna, 'frequencia_absoluta']
    df_to_plot.sort_values(by=coluna, inplace=True)

    f = sns.barplot(x=coluna, y='frequencia_absoluta', data=df_to_plot, ax=eixos[eixo])
    f.set(title=titulos[eixo], xlabel=coluna.capitalize(), ylabel='Frequência Absoluta')

    f.set_xticks(range(len(df_to_plot)))
    f.set_xticklabels(df_to_plot[coluna], rotation=90)

    _, max_y_f = f.get_ylim()
    max_y_value = np.maximum(max_y_value, max_y_f)
    f.set(ylim=(0, max_y_value))

    eixo += 1

plt.show()

"""Analisando os gráficos acima, podemos observar como o estado civil dos clientes é **pouco impactante** na influência de tornarem-se inadimplentes. Os dois primeiros gráficos são muito **similares**, mostrando que o estado civil de clientes adimplentes tende a **imitar** o gráfico de estado civil de todos os clientes.

No terceiro gráfico temos uma sutil diferença, mostrando que a frequência absoluta de inadimplentes é **praticamente a mesma** entre clientes casados e solteiros.

Agora, um gráfico usando `salario_anual`:
"""

coluna = 'salario_anual'
titulos = ['Salário anual dos Clientes', 'Salário anual dos Clientes Adimplentes', 'Salário anual dos Clientes Inadimplentes']

eixo = 0
max_y_value = 0

figura, eixos = plt.subplots(1, 3, figsize=(20, 5), sharex=True)

for dataframe in [df, df_adimplentes, df_inadimplentes]:
    df_to_plot = dataframe[coluna].value_counts().reset_index()
    df_to_plot.columns = [coluna, 'frequencia_absoluta']
    df_to_plot.sort_values(by=coluna, inplace=True)

    f = sns.barplot(x=coluna, y='frequencia_absoluta', data=df_to_plot, ax=eixos[eixo])
    f.set(title=titulos[eixo], xlabel=coluna.capitalize(), ylabel='Frequência Absoluta')

    f.set_xticks(range(len(df_to_plot)))
    f.set_xticklabels(df_to_plot[coluna], rotation=90)

    _, max_y_f = f.get_ylim()
    max_y_value = np.maximum(max_y_value, max_y_f)
    f.set(ylim=(0, max_y_value))

    eixo += 1

plt.show()

"""Nos gráficos acima mostrando a faixa salarial dos clientes, podemos inferir que **não** há diferença significativa entre clientes adimplentes ou inadimplentes, por mais que seja um dado muitas vezes **apelativo**.

Por mais que não exista diferença relevante, é um fato **revelador**.

Agora, usaremos duas variáveis preditivas numéricas para comparações.
"""

df.drop(['id', 'default'], axis=1).select_dtypes('number').head(n=5)  # usaremos qtd_transacoes_12m e valor_transacoes_12m

"""Primeiramente, um gráfico de **subplots** usando a coluna de `qtd_transacoes_12m`:"""

coluna = 'qtd_transacoes_12m'
titulos = ['Qtd. de Transações no Último Ano', 'Qtd. de Transações no Último Ano de Adimplentes', 'Qtd. de Transações no Último Ano de Inadimplentes']

eixo = 0
max_y = 0
figura, eixos = plt.subplots(1,3, figsize=(20, 5), sharex=True)

for dataframe in [df, df_adimplentes, df_inadimplentes]:

  f = sns.histplot(x=coluna, data=dataframe, stat='count', ax=eixos[eixo])
  f.set(title=titulos[eixo], xlabel=coluna.capitalize(), ylabel='Frequência Absoluta')

  _, max_y_f = f.get_ylim()
  max_y = max_y_f if max_y_f > max_y else max_y
  f.set(ylim=(0, max_y))

  eixo += 1

plt.show()

"""Aqui, podemos ver diferenças **significativas**.

Vemos que grande parte dos clientes fizeram entre **20 e 40** transações; e entre **60 e 80** transações nos últimos 12 meses. Observando o gráfico de adimplentes, os picos de 60 e 80 transações são relativamente parecidos, mas temos uma **brusca diminuição** nos picos de usuários que realizaram entre 20 e 40 transações bancárias. Tal qual diferença que é **compensada** tomando como base o **terceiro gráfico**, onde há uma quebra de paradigma.

No último, vemos que existe um **pico distante** dos outros entre **35 e 45** transações por **inadimplentes**, enquanto não existe **saliência alguma** entre **60 e 80**. Isso nos mostra que clientes que realizam entre 35 e 45 transações por ano têm **mais** chances de tornarem-se inadimplentes.

Segundamente, a coluna de `valor_transacoes_12m`:
"""

coluna = 'valor_transacoes_12m'
titulos = ['Valor das Transações no Último Ano', 'Valor das Transações no Último Ano de Adimplentes', 'Valor das Transações no Último Ano de Inadimplentes']

eixo = 0
max_y = 0
figura, eixos = plt.subplots(1,3, figsize=(20, 5), sharex=True)

for dataframe in [df, df_adimplentes, df_inadimplentes]:

  f = sns.histplot(x=coluna, data=dataframe, stat='count', ax=eixos[eixo])
  f.set(title=titulos[eixo], xlabel=coluna.capitalize(), ylabel='Frequência Absoluta')

  _, max_y_f = f.get_ylim()
  max_y = max_y_f if max_y_f > max_y else max_y
  f.set(ylim=(0, max_y))

  eixo += 1

plt.show()

"""Novamente, vemos uma grande variabilidade aqui.

Muitos clientes do banco realizaram transações entre **1000,00** e **2000,00** reais; e entre **3000,00** e **4000,00** reais nos últimos 12 meses, ambos aproximadamente. O segundo gráfico tende a **imitar** o primeiro, sendo os adimplentes a maioria da base de dados.

No terceiro gráfico temos a **compensação** da depressão vista entre **2000,00** e **2500,00** reais no segundo gráfico. Nos mostra que essa faixa de valores tendem a ser as quantias de dinheiro transacionadas por clientes **inadimplentes**.

Por fim, vamos gerar um gráfico de **dispersão** juntando as colunas `valor_transacoes_12m` e `qtd_transacoes_12m` para análise:
"""

f = sns.relplot(x='valor_transacoes_12m', y='qtd_transacoes_12m', data=df, hue='default')
_ = f.set(
    title='Relação entre Valor e Quantidade de Transações no Último Ano',
    xlabel='Valor das Transações no Último Ano',
    ylabel='Quantidade das Transações no Último Ano'
  )

"""Com esse gráfico esclarecedor, podemos inferir que **grande parte** de **inadimplência** nessas variáveis estão presentes em clientes com as seguintes características:

-> Clientes que realizaram entre **20 e 60** transações nos últimos 12 meses, com valores entre **1000,00** e **2500,00** reais;

-> Clientes que realizaram entre **60 e 80** transações nos últimos 12 meses, com valores entre **7500,00** e **10.000,00** reais.

-> Alguns clientes que realizaram entre **40 e 80** transações nos últimos 12 meses, com valores entre **4500,00** e **7500,00** reais.

# 5. Considerações finais

Em suma, considerando todos os métodos e linhas de raciocínio empregadas no presente notebook, temos alguns *insights* para tirarmos:

**->** Variáveis categóricas **apelativas** como **estado civil** e **faixa salarial** têm praticamente nenhuma relação ao menos significativa no quesito de um cliente tornar-se inadimplente, em sua maioria;

**->** Observamos que as duas variáveis numéricas trabalhadas demonstram **particularidades** quando comparadas entre clientes adimplentes e inadimplentes;

**->** a maior faixa de clientes inadimplentes está concentrada entre aqueles que realizaram entre **20** e **80** transações nos últimos 12 meses, com valores entre **1000,00** e **10.000,00** reais.

Com base nisso, podem-se ser discutidos meios para amenizar a tendência a inadimplência de clientes.
"""